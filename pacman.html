<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman | Spel</title>
    <!-- Fonts from the original page -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <!-- New font for the 80s theme -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Shared styles from the original page */
        :root {
            --primary-bg: #1a1a1a;
            --secondary-bg: #2b2b2b;
            --text-color: #f5f5f5;
            --accent-color: #3498db;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        /* Retro game specific styles */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            padding: 20px;
            background-color: #0d0d0d;
            background-image: linear-gradient(0deg, transparent 24%, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, .05) 75%, rgba(255, 255, 255, .05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, .05) 75%, rgba(255, 255, 255, .05) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
        }

        /* Back button styling */
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            text-decoration: none;
            color: #00ffff; /* Neon Cyan */
            font-family: 'Press Start 2P', cursive;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff, inset 0 0 10px #00ffff;
            padding: 10px 15px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            text-shadow: 0 0 5px #00ffff;
            z-index: 10;
        }

        .back-button:hover {
            color: #ff00ff; /* Neon Pink */
            background: rgba(255, 0, 255, 0.2);
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff, inset 0 0 15px #ff00ff;
            transform: scale(1.05);
            text-shadow: 0 0 5px #ff00ff;
        }
        
        /* Version tag styling */
        .version-tag {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            color: rgba(0, 255, 255, 0.5); /* Faded neon cyan */
            text-shadow: 0 0 2px rgba(0, 255, 255, 0.2);
            font-size: 0.8em;
            z-index: 10;
        }

        /* Game canvas and UI */
        canvas {
            background-color: #000;
            border: 5px solid #ff00ff;
            box-shadow: 0 0 20px #ff00ff, inset 0 0 20px #ff00ff;
            border-radius: 8px;
            margin-top: 20px;
            outline: none;
        }

        #game-info {
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            margin-top: 20px;
            text-shadow: 0 0 5px #00ffff;
        }

        #score-display, #high-score-display {
            font-size: 1.5em;
        }

        #message {
            font-size: 1.2em;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }
        
        #instructions {
            font-family: 'Press Start 2P', cursive;
            color: #f5f5f5;
            text-shadow: 0 0 2px #f5f5f5;
            margin-top: 40px;
            max-width: 600px;
            line-height: 1.8;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
            border-radius: 8px;
        }
        #instructions h2 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }
        #instructions li {
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        #highscore-list-container {
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            margin-top: 40px;
            max-width: 600px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
            border-radius: 8px;
        }
        #highscore-list-container h2 {
            font-size: 1.2em;
            margin-bottom: 20px;
            text-align: center;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }
        #highscore-list-container ol {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #highscore-list-container li {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 1em;
        }
        #highscore-list-container li:last-child {
            margin-bottom: 0;
        }
        .highscore-initials {
            color: #f5f5f5;
        }
        .highscore-score {
            color: #00ffff;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal {
            background-color: #1a1a1a;
            border: 2px solid #ff00ff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 20px #ff00ff;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }

        .modal h2 {
            font-size: 2em;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .modal-button {
            background: #00ffff;
            color: #1a1a1a;
            border: none;
            padding: 10px 20px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s ease-in-out;
            margin-top: 20px;
            text-shadow: none;
        }

        .modal-button:hover {
            background: #ff00ff;
            color: #fff;
            box-shadow: 0 0 10px #ff00ff;
        }

        /* New modal for initials */
        #initialsModal h2 {
            color: #f5f5f5;
        }
        .initials-input-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        .initial-char {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            text-align: center;
            border: 2px solid #00ffff;
            background: rgba(0, 0, 0, 0.4);
            color: #f5f5f5;
            transition: all 0.2s;
            box-shadow: inset 0 0 5px #00ffff;
        }
        .initial-char.selected {
            border-color: #ff00ff;
            color: #ff00ff;
            box-shadow: 0 0 10px #ff00ff, inset 0 0 10px #ff00ff;
            transform: scale(1.1);
        }
    </style>
</head>
<body>

    <a href="index.html" class="back-button">Tillbaka till menyn</a>
    <span class="version-tag">Ver 2.0</span>

    <div class="game-container">
        <div id="game-info">
            <h1>Pac-Man</h1>
            <p>
                <span id="score-display">Poäng: 0</span> | 
                <span id="high-score-display">Highscore: 0</span>
            </p>
            <p id="message">Klicka för att börja!</p>
        </div>
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        
        <div id="instructions">
            <h2>Hur man spelar</h2>
            <ul>
                <li>Ät alla prickar utan att bli fångad av spökena.</li>
                <li>Ät de större power-pellets för att göra spökena sårbara.</li>
                <li>Använd **piltangenterna** (upp, ner, vänster, höger) för att röra dig.</li>
                <li>På mobilen, **svep i önskad riktning** på skärmen.</li>
            </ul>
        </div>

        <!-- Highscore list -->
        <div id="highscore-list-container">
            <h2>Topp 10 Highscore</h2>
            <p id="loading-highscores">Laddar highscores...</p>
            <ol id="highscore-list"></ol>
        </div>
    </div>

    <!-- Modals for game messages -->
    <div id="gameOverModal" class="modal-overlay">
        <div class="modal">
            <h2>Game Over</h2>
            <p>Din poäng: <span id="finalScore">0</span></p>
            <p id="newHighScoreMessage" style="color: #ff00ff; display: none;">Ny highscore!</p>
            <button class="modal-button" onclick="window.location.reload()">Spela igen</button>
        </div>
    </div>

    <!-- New modal for initials -->
    <div id="initialsModal" class="modal-overlay">
        <div class="modal">
            <h2>Grattis! Ny highscore!</h2>
            <p>Ange dina initialer (3 bokstäver):</p>
            <div class="initials-input-container">
                <span id="initial-char-0" class="initial-char selected">A</span>
                <span id="initial-char-1" class="initial-char">A</span>
                <span id="initial-char-2" class="initial-char">A</span>
            </div>
            <button class="modal-button" id="saveInitialsBtn">Spara poäng</button>
        </div>
    </div>

    <!-- Firebase SDK-skript -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, getDocs, addDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        // --- FIREBASE SETUP ---
        // Din Firebase-konfiguration från den tillhandahållna filen
        const firebaseConfig = {
            apiKey: "AIzaSyCorCZf8cH8vD1v47aOADdW3x0hCWlVUfw",
            authDomain: "kumlaskytte.firebaseapp.com",
            projectId: "kumlaskytte",
            storageBucket: "kumlaskytte.firebasestorage.app",
            messagingSenderId: "571676149705",
            appId: "1:571676149705:web:a0ace868f4680298a78a18",
            measurementId: "G-KSJ9NLNDBX"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        let userId = null;
        let topTenHighscores = [];
        
        // Logga in anonymt för att få ett användar-ID
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("Firebase ansluten. Användar-ID:", userId);
                await getHighScores();
            } else {
                console.log("Firebase ansluten. Loggar in anonymt...");
                await signInAnonymously(auth);
            }
        });

        const getHighScores = async () => {
            const highscoreListEl = document.getElementById("highscore-list");
            const loadingMessage = document.getElementById("loading-highscores");
            
            if (!db) {
                console.error("Databasen är inte ansluten.");
                loadingMessage.textContent = "Kunde inte ladda highscores.";
                return;
            }

            try {
                // Hämta highscores från subkollektionen för Pacman
                const scoresRef = collection(db, "highscores", "pacman", "scores");
                const q = query(scoresRef, orderBy("score", "desc"));
                const querySnapshot = await getDocs(q);

                topTenHighscores = [];
                querySnapshot.forEach(doc => {
                    topTenHighscores.push({ id: doc.id, ...doc.data() });
                });
                
                topTenHighscores.sort((a, b) => b.score - a.score);
                
                highscoreListEl.innerHTML = '';
                loadingMessage.style.display = 'none';

                if (topTenHighscores.length > 0) {
                    topTenHighscores.slice(0, 10).forEach((item, index) => {
                        const li = document.createElement("li");
                        li.innerHTML = `
                            <span>${index + 1}. <span class="highscore-initials">${item.initials}</span></span>
                            <span class="highscore-score">${item.score}</span>
                        `;
                        highscoreListEl.appendChild(li);
                    });
                    document.getElementById("high-score-display").textContent = `Highscore: ${topTenHighscores[0].score}`;
                } else {
                    highscoreListEl.innerHTML = '<li>Inga highscores än. Var den första!</li>';
                }

                console.log("Highscores hämtade från Firebase.");
            } catch (e) {
                console.error("Fel vid hämtning av highscores:", e);
                loadingMessage.textContent = "Kunde inte ladda highscores.";
            }
        };

        const saveHighScore = async (newScore, initials) => {
            if (!userId) {
                console.error("Användar-ID saknas, kan inte spara highscore.");
                return;
            }
            try {
                const scoresRef = collection(db, "highscores", "pacman", "scores");
                
                await addDoc(scoresRef, {
                    initials: initials.toUpperCase(),
                    score: newScore,
                    timestamp: new Date()
                });

                console.log("Ny highscore sparad till Firebase:", newScore);
                await getHighScores(); 
            } catch (e) {
                console.error("Fel vid sparande av highscore:", e);
            }
        };


        // --- GAME LOGIC (PAC-MAN) ---
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score-display");
        const messageDisplay = document.getElementById("message");
        const gameOverModal = document.getElementById("gameOverModal");
        const initialsModal = document.getElementById("initialsModal");
        const finalScoreDisplay = document.getElementById("finalScore");

        const TILE_SIZE = 20;
        const MAP_WIDTH = 28;
        const MAP_HEIGHT = 31;
        const GHOST_FRIGHTENED_COLOR = 'rgb(30, 60, 255)';
        const GHOST_SCARED_BLINK_COLOR = 'rgb(255, 255, 255)';
        const GHOST_EYES_COLOR = 'rgb(50, 50, 255)';

        canvas.width = MAP_WIDTH * TILE_SIZE;
        canvas.height = MAP_HEIGHT * TILE_SIZE;

        let gameMap = [];
        let score = 0;
        let dotsLeft = 0;
        let lives = 3;
        let frightenedGhostsEaten = 0;
        let frightenedTimer = 0;
        let gameRunning = false;
        let level = 1;
        const ghostPoints = [200, 400, 800, 1600];
        
        // This is a simplified map based on the original game's layout.
        // W: Wall, D: Dot, P: Power Pellet, G: Ghost Gate, S: Spökenas startposition
        const PACMAN_MAP = [
            "WWWWWWWWWWWWWWWWWWWWWWWWWWWW",
            "WPPPPPPPPPPWWPWWPPPPPPPPPPPPW",
            "W PWWWWWW PWWPWWPWWWWWW P W",
            "W PWWDW WDWWWWWWWDWWDDDWP W",
            "WPDW P DWDDDDWWDDDWDPD P DW",
            "W WWWW DWWDWW W WWWW DW WW",
            "W W P DW W W W W W W DW P W",
            "W W W W WWWDWWWW WDW W W W",
            "WDDDDDDDWDWDDDWDWDWDDDWDDDW",
            "W WWWWWWWDWWWWWWWDWWWWWW W",
            "W WWWWWDDDWP WWWDW DD WWWW W",
            "W WWWWW WWWWPWWWWW WWWWWW WW",
            "WDDDDDDDPDWDDWDDDDDPDDDDDDPW",
            "WWWWWWWWWWW  S SWWWWWWWWWWW",
            "WWWWWWWWWWW GGGWWWWWWWWWWWW",
            "WWWWWWWWWWWW G WWWWWWWWWWWW",
            "WWWWWWWWWWWW G WWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWWWWW",
            "WDDDDDW DD WDDDDDW DD WDDDDW",
            "WDWWWWWDWWWDWDDWDWWWWWDWWWDW",
            "WDW WW DWDDW DWWWDWDDDW WD",
            "W WW DWWDW WWDWDWW WD W WD",
            "W WWWWW WD WDWWDW WWWWW WD",
            "WDDDWDDDWDDDWDDDWDDDWDDDDDW",
            "WDDDWWWWWWWWWWWWWWWWWWWDWDDW",
            "WDWWDWDWWDW DWDWWDWDWWDWWDW",
            "WDWWDWDDDWDDDWDDDWDDWWDWWDW",
            "WDDDDWDWWWWWWWWWWWWWWWWWWWDW",
            "WDWWWDWDDDDDWWDDDDWDDDDDDW",
            "WDPD WDWWWWWWWWWWWWWW W DW W",
            "WWWWWDWDDDDDDDDDDDDDDDWDDDWW"
        ];
        
        const DIRECTIONS = {
            'UP': {x: 0, y: -1},
            'DOWN': {x: 0, y: 1},
            'LEFT': {x: -1, y: 0},
            'RIGHT': {x: 1, y: 0},
            'NONE': {x: 0, y: 0}
        };

        const GHOST_COLORS = {
            'Blinky': 'red',
            'Pinky': 'pink',
            'Inky': 'cyan',
            'Clyde': 'orange'
        };

        let pacman = {
            x: 13.5 * TILE_SIZE, y: 23 * TILE_SIZE,
            tileX: 13, tileY: 23,
            dir: 'NONE',
            nextDir: 'NONE',
            speed: 2,
            mouthOpen: 0,
            mouthSpeed: 0.1
        };

        let ghosts = [
            { name: 'Blinky', x: 13.5 * TILE_SIZE, y: 14 * TILE_SIZE, startTile: {x: 13, y: 14}, color: 'red', dir: 'NONE', frightened: false, scaredTimer: 0, eaten: false },
            { name: 'Pinky', x: 12.5 * TILE_SIZE, y: 14 * TILE_SIZE, startTile: {x: 12, y: 14}, color: 'pink', dir: 'NONE', frightened: false, scaredTimer: 0, eaten: false },
            { name: 'Inky', x: 14.5 * TILE_SIZE, y: 14 * TILE_SIZE, startTile: {x: 14, y: 14}, color: 'cyan', dir: 'NONE', frightened: false, scaredTimer: 0, eaten: false },
            { name: 'Clyde', x: 15.5 * TILE_SIZE, y: 14 * TILE_SIZE, startTile: {x: 15, y: 14}, color: 'orange', dir: 'NONE', frightened: false, scaredTimer: 0, eaten: false }
        ];

        let ghostScatterTimer = 0;
        const SCATTER_DURATION = 10 * 60; // 10 sekunder i frames (60 fps)
        const CHASE_DURATION = 20 * 60;   // 20 sekunder i frames
        let ghostMode = 'chase';
        let ghostModeTimer = 0;

        // Initials entry mode
        let initialsEntryMode = false;
        const characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split('');
        let currentInitials = ['A', 'A', 'A'];
        let selectedInitialIndex = 0;

        const renderInitials = () => {
            document.getElementById('initial-char-0').textContent = currentInitials[0];
            document.getElementById('initial-char-1').textContent = currentInitials[1];
            document.getElementById('initial-char-2').textContent = currentInitials[2];

            // Update selection highlight
            document.querySelectorAll('.initial-char').forEach((el, index) => {
                el.classList.toggle('selected', index === selectedInitialIndex);
            });
        };

        const initGame = () => {
            gameMap = PACMAN_MAP.map(row => row.split(''));
            dotsLeft = 0;
            powerPelletsLeft = 0;
            lives = 3;
            score = 0;
            level = 1;
            frightenedGhostsEaten = 0;
            ghostModeTimer = 0;
            
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (gameMap[y][x] === 'P' || gameMap[y][x] === 'D') {
                        dotsLeft++;
                    }
                    if (gameMap[y][x] === 'P') {
                        powerPelletsLeft++;
                    }
                }
            }
        };

        const drawMap = () => {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const tile = gameMap[y][x];
                    const screenX = x * TILE_SIZE;
                    const screenY = y * TILE_SIZE;
                    if (tile === 'W') {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    } else if (tile === 'D') {
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (tile === 'P') {
                        if (frightenedTimer % 30 < 15) {
                             ctx.fillStyle = 'white';
                             ctx.beginPath();
                             ctx.arc(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, 5, 0, Math.PI * 2);
                             ctx.fill();
                        }
                    } else if (tile === 'G') {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(screenX, screenY + TILE_SIZE / 2 - 2, TILE_SIZE, 4);
                    }
                }
            }
        };
        
        const drawPacman = () => {
            const angle = Math.atan2(DIRECTIONS[pacman.dir].y, DIRECTIONS[pacman.dir].x);
            const mouthAngle = pacman.mouthOpen * Math.PI / 4;
            const startAngle = angle + mouthAngle;
            const endAngle = angle - mouthAngle;
            
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(pacman.x, pacman.y, TILE_SIZE / 2 - 2, startAngle, endAngle);
            ctx.lineTo(pacman.x, pacman.y);
            ctx.fill();
            
            pacman.mouthOpen += pacman.mouthSpeed;
            if (pacman.mouthOpen > 1 || pacman.mouthOpen < 0) {
                pacman.mouthSpeed *= -1;
            }
        };
        
        const drawGhost = (ghost) => {
            let color = GHOST_COLORS[ghost.name];
            if (ghost.frightened) {
                color = frightenedTimer > 180 || (frightenedTimer % 20 < 10) ? GHOST_FRIGHTENED_COLOR : GHOST_SCARED_BLINK_COLOR;
            } else if (ghost.eaten) {
                color = GHOST_EYES_COLOR;
            }
            
            // Draw ghost body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(ghost.x, ghost.y, TILE_SIZE / 2 - 2, Math.PI, 0, false);
            ctx.lineTo(ghost.x + TILE_SIZE/2 - 2, ghost.y + TILE_SIZE/2 - 2);
            ctx.lineTo(ghost.x - TILE_SIZE/2 + 2, ghost.y + TILE_SIZE/2 - 2);
            ctx.fill();
        };

        const movePacman = () => {
            const centerX = pacman.tileX * TILE_SIZE + TILE_SIZE/2;
            const centerY = pacman.tileY * TILE_SIZE + TILE_SIZE/2;

            if (pacman.x === centerX && pacman.y === centerY) {
                pacman.dir = pacman.nextDir;
            }
            
            const dir = DIRECTIONS[pacman.dir];
            const nextTileX = pacman.tileX + dir.x;
            const nextTileY = pacman.tileY + dir.y;
            
            if (gameMap[nextTileY][nextTileX] === 'W') {
                pacman.dir = 'NONE';
            }

            if (pacman.dir !== 'NONE') {
                pacman.x += dir.x * pacman.speed;
                pacman.y += dir.y * pacman.speed;

                // Teleporting through tunnels
                if (pacman.x < 0) pacman.x = canvas.width;
                if (pacman.x > canvas.width) pacman.x = 0;
            }

            pacman.tileX = Math.floor(pacman.x / TILE_SIZE);
            pacman.tileY = Math.floor(pacman.y / TILE_SIZE);
        };
        
        const getGhostTarget = (ghost) => {
            if (ghost.frightened) {
                // Frightened mode: random target
                const possibleTiles = [];
                for (let y = 0; y < MAP_HEIGHT; y++) {
                    for (let x = 0; x < MAP_WIDTH; x++) {
                        if (gameMap[y][x] !== 'W') {
                            possibleTiles.push({x, y});
                        }
                    }
                }
                return possibleTiles[Math.floor(Math.random() * possibleTiles.length)];
            } else {
                // Chase mode: Pacman's position
                return {x: pacman.tileX, y: pacman.tileY};
            }
        };

        const moveGhosts = () => {
            ghosts.forEach(ghost => {
                // If ghost is at a tile center, make a decision
                const centerX = ghost.startTile.x * TILE_SIZE + TILE_SIZE/2;
                const centerY = ghost.startTile.y * TILE_SIZE + TILE_SIZE/2;
                
                if (Math.abs(ghost.x - centerX) < 1 && Math.abs(ghost.y - centerY) < 1) {
                    ghost.x = centerX;
                    ghost.y = centerY;

                    const target = getGhostTarget(ghost);
                    let bestDir = null;
                    let minDistance = Infinity;

                    // Exclude reverse direction
                    const oppositeDir = {
                        'UP': 'DOWN', 'DOWN': 'UP',
                        'LEFT': 'RIGHT', 'RIGHT': 'LEFT',
                        'NONE': 'NONE'
                    }[ghost.dir];
                    
                    ['UP', 'DOWN', 'LEFT', 'RIGHT'].forEach(dirName => {
                        const dir = DIRECTIONS[dirName];
                        const nextTileX = ghost.startTile.x + dir.x;
                        const nextTileY = ghost.startTile.y + dir.y;
                        
                        if (dirName !== oppositeDir && gameMap[nextTileY][nextTileX] !== 'W' && gameMap[nextTileY][nextTileX] !== 'G') {
                            const distance = Math.sqrt(Math.pow(nextTileX - target.x, 2) + Math.pow(nextTileY - target.y, 2));
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestDir = dirName;
                            }
                        }
                    });

                    if (bestDir) {
                        ghost.dir = bestDir;
                    }
                }

                const dir = DIRECTIONS[ghost.dir];
                ghost.x += dir.x * (ghost.frightened ? 1.5 : 2);
                ghost.y += dir.y * (ghost.frightened ? 1.5 : 2);
            });
        };

        const checkCollisions = () => {
            const tile = gameMap[pacman.tileY][pacman.tileX];
            if (tile === 'D') {
                score += 10;
                dotsLeft--;
                gameMap[pacman.tileY][pacman.tileX] = ' ';
                scoreDisplay.textContent = `Poäng: ${score}`;
            } else if (tile === 'P') {
                score += 50;
                powerPelletsLeft--;
                gameMap[pacman.tileY][pacman.tileX] = ' ';
                frightenedGhostsEaten = 0;
                ghosts.forEach(ghost => ghost.frightened = true);
                frightenedTimer = 420; // 7 seconds
            }

            ghosts.forEach(ghost => {
                const dx = pacman.x - ghost.x;
                const dy = pacman.y - ghost.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < TILE_SIZE) {
                    if (ghost.frightened) {
                        ghost.eaten = true;
                        ghost.frightened = false;
                        ghost.x = ghost.startTile.x * TILE_SIZE + TILE_SIZE/2;
                        ghost.y = ghost.startTile.y * TILE_SIZE + TILE_SIZE/2;
                        frightenedGhostsEaten++;
                        score += ghostPoints[frightenedGhostsEaten - 1];
                        scoreDisplay.textContent = `Poäng: ${score}`;
                    } else if (!ghost.eaten) {
                        lives--;
                        if (lives > 0) {
                            resetState();
                        } else {
                            gameOver();
                        }
                    }
                }
            });

            if (dotsLeft === 0) {
                // Game won
                gameOver(true);
            }
        };

        const resetState = () => {
            pacman.x = 13.5 * TILE_SIZE;
            pacman.y = 23 * TILE_SIZE;
            pacman.dir = 'NONE';
            pacman.nextDir = 'NONE';
            
            ghosts.forEach((ghost, index) => {
                ghost.x = (12.5 + index) * TILE_SIZE;
                ghost.y = 14.5 * TILE_SIZE;
                ghost.dir = 'NONE';
                ghost.frightened = false;
                ghost.eaten = false;
            });
            frightenedTimer = 0;
        };

        const gameLoop = () => {
            if (!gameRunning) return;

            if (frightenedTimer > 0) {
                frightenedTimer--;
            }

            movePacman();
            moveGhosts();
            checkCollisions();
            drawMap();
            drawPacman();
            ghosts.forEach(drawGhost);
            
            requestAnimationFrame(gameLoop);
        };

        const startGame = () => {
            if (gameRunning) return;
            gameRunning = true;
            score = 0;
            scoreDisplay.textContent = `Poäng: 0`;
            messageDisplay.textContent = "";
            gameOverModal.style.display = "none";
            initialsModal.style.display = "none";
            initGame();
            gameLoop();
        };

        const gameOver = (win = false) => {
            gameRunning = false;
            finalScoreDisplay.textContent = score;
            gameOverModal.style.display = "flex";
            
            if (win) {
                document.querySelector('#gameOverModal h2').textContent = 'Du vann!';
            }

            if (score > 0 && (topTenHighscores.length < 10 || score > topTenHighscores[topTenHighscores.length - 1].score)) {
                document.getElementById("newHighScoreMessage").style.display = "block";
                initialsEntryMode = true;
                
                setTimeout(() => {
                    gameOverModal.style.display = "none";
                    initialsModal.style.display = "flex";
                    selectedInitialIndex = 0; 
                    renderInitials();
                }, 2000); 
            } else {
                saveHighScore(score, "---"); 
            }
        };
        
        // Event listener för att spara initialer
        document.getElementById("saveInitialsBtn").addEventListener("click", () => {
            const initials = currentInitials.join('');
            saveHighScore(score, initials);
            initialsEntryMode = false;
            initialsModal.style.display = "none";
        });

        // Tangentbordskontroller
        document.addEventListener("keydown", (e) => {
            if (initialsEntryMode) {
                const charIndex = characterSet.indexOf(currentInitials[selectedInitialIndex]);
                if (e.key === "ArrowLeft") {
                    selectedInitialIndex = (selectedInitialIndex - 1 + 3) % 3;
                    renderInitials();
                } else if (e.key === "ArrowRight") {
                    selectedInitialIndex = (selectedInitialIndex + 1) % 3;
                    renderInitials();
                } else if (e.key === "ArrowUp") {
                    const newCharIndex = (charIndex + 1) % characterSet.length;
                    currentInitials[selectedInitialIndex] = characterSet[newCharIndex];
                    renderInitials();
                } else if (e.key === "ArrowDown") {
                    const newCharIndex = (charIndex - 1 + characterSet.length) % characterSet.length;
                    currentInitials[selectedInitialIndex] = characterSet[newCharIndex];
                    renderInitials();
                } else if (e.key === "Enter") {
                    document.getElementById("saveInitialsBtn").click();
                }
            } else {
                 if (!gameRunning) {
                     startGame();
                 }
                 if (e.key === 'ArrowUp') pacman.nextDir = 'UP';
                 if (e.key === 'ArrowDown') pacman.nextDir = 'DOWN';
                 if (e.key === 'ArrowLeft') pacman.nextDir = 'LEFT';
                 if (e.key === 'ArrowRight') pacman.nextDir = 'RIGHT';
            }
        });
        
        // Touch-händelser för mobil
        let touchStartX = null;
        let touchStartY = null;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            
            if (!gameRunning) {
                startGame();
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            if (initialsEntryMode) {
                // This part of the code is not optimized for touch, so we will skip.
                return;
            }

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    pacman.nextDir = 'RIGHT';
                } else {
                    pacman.nextDir = 'LEFT';
                }
            } else {
                if (deltaY > 0) {
                    pacman.nextDir = 'DOWN';
                } else {
                    pacman.nextDir = 'UP';
                }
            }
        });

    </script>
</body>
</html>
