<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocktris | Spel</title>
    <!-- Fonts from the original page -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <!-- New font for the 80s theme -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Base styles for the page background and text */
        :root {
            --primary-bg: #1a1a1a;
            --secondary-bg: #2b2b2b;
            --text-color: #f5f5f5;
            --accent-color: #3498db;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            overflow: hidden; /* Prevent scrollbars from showing */
        }

        /* Retro game container styling */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            padding: 20px;
            background-color: #0d0d0d;
            background-image: linear-gradient(0deg, transparent 24%, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, .05) 75%, rgba(255, 255, 255, .05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(255, 255, 255, .05) 25%, rgba(255, 255, 255, .05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, .05) 75%, rgba(255, 255, 255, .05) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
        }

        /* Back button styling */
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            text-decoration: none;
            color: #00ffff; /* Neon Cyan */
            font-family: 'Press Start 2P', cursive;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff, inset 0 0 10px #00ffff;
            padding: 10px 15px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            text-shadow: 0 0 5px #00ffff;
            z-index: 10;
        }
        .back-button:hover {
            color: #ff00ff; /* Neon Pink */
            background: rgba(255, 0, 255, 0.2);
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff, inset 0 0 15px #ff00ff;
            transform: scale(1.05);
            text-shadow: 0 0 5px #ff00ff;
        }
        
        /* Version tag styling */
        .version-tag {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            color: rgba(0, 255, 255, 0.5); /* Faded neon cyan */
            text-shadow: 0 0 2px rgba(0, 255, 255, 0.2);
            font-size: 0.8em;
            z-index: 10;
        }

        #game-info {
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            margin-top: 20px;
            text-shadow: 0 0 5px #00ffff;
        }

        #score-display, #high-score-display {
            font-size: 1.5em;
        }

        #message {
            font-size: 1.2em;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }
        
        #game-board-container {
            border: 2px solid #00ff00;
            display: inline-block;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            border-collapse: collapse;
            width: 400px;
            height: 400px;
            background: #222;
        }

        .grid-cell {
            border: 1px solid #444;
            background-color: #1a1a1a;
            box-sizing: border-box;
        }
        
        .placed {
            background-color: #00ff00;
            box-shadow: inset 0 0 5px #00ff00;
        }

        .shadow {
            background-color: rgba(0, 255, 0, 0.5);
        }

        .invalid-placement {
            background-color: red;
        }

        #next-piece-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }

        .next-piece-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            width: 100px;
            height: 100px;
            border: 2px solid #00ff00;
            background: #222;
        }

        .next-piece-cell {
            background-color: #1a1a1a;
        }
        
        .next-piece-block {
            background-color: #00ff00;
            box-shadow: inset 0 0 5px #00ff00;
        }

        .game-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        .game-controls button {
            font-family: 'Press Start 2P', cursive;
            padding: 10px 15px;
            border: 2px solid #ff00ff;
            background: rgba(255, 0, 255, 0.2);
            color: #ff00ff;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 5px #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }

        .game-controls button.selected {
            background: rgba(0, 255, 255, 0.4);
            border-color: #00ffff;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }

        #instructions {
            font-family: 'Press Start 2P', cursive;
            color: #f5f5f5;
            text-shadow: 0 0 2px #f5f5f5;
            margin-top: 40px;
            max-width: 600px;
            line-height: 1.8;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
            border-radius: 8px;
        }
        #instructions h2 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }
        #instructions li {
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .start-game-button {
            font-family: 'Press Start 2P', cursive;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 30px;
            font-size: 1.5em;
            border: 2px solid #00ffff;
            background: rgba(0, 0, 0, 0.4);
            color: #00ffff;
            cursor: pointer;
            text-shadow: 0 0 5px #00ffff;
            box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
            transition: all 0.2s;
            z-index: 5;
        }

        .start-game-button:hover {
            color: #ff00ff;
            border-color: #ff00ff;
            box-shadow: 0 0 20px #ff00ff, inset 0 0 20px #ff00ff;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s ease;
            opacity: 0;
        }

        .modal-overlay.active {
            display: flex; /* Show when active */
            opacity: 1;
        }
        
        .modal {
            background: #1a1a1a;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 20px #ff00ff;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
        }

        .modal-button {
            font-family: 'Press Start 2P', cursive;
            padding: 10px 20px;
            margin-top: 20px;
            border: 2px solid #00ffff;
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 5px #00ffff;
        }

        .modal-button:hover {
            background: rgba(255, 0, 255, 0.2);
            border-color: #ff00ff;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }

        .initials-input-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .initial-char {
            font-size: 2em;
            width: 1em;
            text-align: center;
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
            transition: border-color 0.2s;
        }

        .initial-char.selected {
            border-bottom-color: #ff00ff;
            color: #ff00ff;
        }
        
    </style>
</head>
<body>

    <a href="index.html" class="back-button">Tillbaka till menyn</a>
    <span class="version-tag">Ver 2.6</span>

    <div class="game-container">
        <div id="game-info">
            <h1>Blocktris</h1>
            <p>
                <span id="score-display">Po√§ng: 0</span> | 
                <span id="high-score-display">Highscore: 0</span>
            </p>
            <p id="message">V√§lj sv√•righetsgrad och tryck "Starta spel"!</p>
        </div>
        
        <div class="game-controls">
            <button id="easy-mode-btn" class="selected">Easy</button>
            <button id="hard-mode-btn">Hard</button>
        </div>
        
        <div id="game-board-container">
            <div id="game-grid" class="grid-container"></div>
            <button id="start-game-btn" class="start-game-button">STARTA SPEL</button>
        </div>

        <div id="next-piece-container">
            <p id="next-piece-text" style="font-family:'Press Start 2P', cursive;">Aktuell figur:</p>
            <div id="next-piece-grid" class="next-piece-grid"></div>
            <button id="rotate-btn" class="game-controls-button" style="display:none;">Rotera ( -1 p)</button>
        </div>

        <div id="instructions">
            <h2>Instruktioner</h2>
            <ul>
                <li>Placera figurer p√• spelplanen. En "skugga" visas n√§r du h√•ller musen √∂ver en ruta.</li>
                <li>Klicka en g√•ng f√∂r att placera figuren.</li>
                <li>Po√§ng ges f√∂r varje placerad figur och bonuspo√§ng f√∂r fulla rader/kolumner.</li>
                <li>I Easy-l√§get kan du rotera figuren med mellanslag eller rotationsknappen, men det kostar 1 po√§ng. I Hard-l√§get g√•r det inte.</li>
                <li>Spelet √§r slut n√§r du inte kan placera fler figurer.</li>
            </ul>
        </div>
    </div>

    <!-- Modals for game messages -->
    <div id="gameOverModal" class="modal-overlay">
        <div class="modal">
            <h2>Game Over</h2>
            <p>Din po√§ng: <span id="finalScore">0</span></p>
            <p id="newHighScoreMessage" style="color: #ff00ff; display: none;">Ny highscore!</p>
            <button class="modal-button" onclick="window.location.reload()">Spela igen</button>
        </div>
    </div>

    <!-- New modal for initials -->
    <div id="initialsModal" class="modal-overlay">
        <div class="modal">
            <h2>Grattis! Ny highscore!</h2>
            <p>Ange dina initialer (3 bokst√§ver):</p>
            <div class="initials-input-container">
                <span id="initial-char-0" class="initial-char selected">A</span>
                <span id="initial-char-1" class="initial-char">A</span>
                <span id="initial-char-2" class="initial-char">A</span>
            </div>
            <button class="modal-button" id="saveInitialsBtn">Spara po√§ng</button>
        </div>
    </div>
    
    <!-- High Score list modal -->
    <div id="highscoreListModal" class="modal-overlay">
        <div class="modal">
            <h2>Highscores</h2>
            <ol id="highscore-list" class="highscore-list"></ol>
            <button class="modal-button" onclick="window.location.reload()">Spela igen</button>
        </div>
    </div>

    <!-- Firebase SDK-skript -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // This is a global variable provided by the Canvas environment.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- FIREBASE SETUP ---
        let app, db, auth, userId = null;
        let topTenHighscores = [];
        let isAuthReady = false;
        let highscoresCollectionRef = null;

        const setupFirebase = async () => {
            try {
                // Initialize Firebase services first
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                // Now that 'db' is initialized, define the collection reference
                highscoresCollectionRef = collection(db, "artifacts", appId, "public", "data", "highscores");

                // Sign in with the provided token, or anonymously if not available
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // Set up the real-time listener once auth is ready
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        console.log("Firebase connected. User ID:", userId);
                        setupHighscoresListener();
                    } else {
                        isAuthReady = false;
                        console.log("User is signed out.");
                    }
                });

            } catch (e) {
                console.error("Error setting up Firebase:", e);
            }
        };

        const setupHighscoresListener = () => {
             // Ensure highscoresCollectionRef is defined before using it
             if (!highscoresCollectionRef) {
                console.error("Highscores collection reference is not set up.");
                return;
             }

             const highscoresQuery = query(highscoresCollectionRef);
             onSnapshot(highscoresQuery, (querySnapshot) => {
                const scores = [];
                querySnapshot.forEach((doc) => {
                    scores.push({ id: doc.id, ...doc.data() });
                });

                // Sort scores in descending order in memory
                scores.sort((a, b) => b.score - a.score);

                // Take the top 10
                topTenHighscores = scores.slice(0, 10);
                
                // Update highscore display
                if (topTenHighscores.length > 0) {
                    document.getElementById("high-score-display").textContent = `Highscore: ${topTenHighscores[0].score}`;
                }
            });
        };

        const saveHighScore = async (newScore, initials) => {
            if (!userId) {
                console.error("User ID is missing, cannot save highscore.");
                return;
            }
            if (!highscoresCollectionRef) {
                console.error("Highscores collection reference is not set up, cannot save.");
                return;
            }
            try {
                // Check if the score is actually a new high score
                const isNewHighscore = topTenHighscores.length < 10 || newScore > (topTenHighscores.length > 0 ? topTenHighscores[topTenHighscores.length - 1].score : 0);
                
                if (isNewHighscore) {
                    await addDoc(highscoresCollectionRef, {
                        initials: initials.toUpperCase(),
                        score: newScore,
                        timestamp: new Date()
                    });
                    console.log("New highscore saved to Firebase:", newScore);
                } else {
                    console.log("Score is not a new highscore, skipping save.");
                }

            } catch (e) {
                console.error("Error saving highscore:", e);
            }
        };

        // --- GAME LOGIC (BLOCKTRIS) ---
        const gameGridEl = document.getElementById('game-grid');
        const nextPieceGridEl = document.getElementById('next-piece-grid');
        const scoreDisplay = document.getElementById('score-display');
        const startGameBtn = document.getElementById('start-game-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const easyModeBtn = document.getElementById('easy-mode-btn');
        const hardModeBtn = document.getElementById('hard-mode-btn');
        const gameControlsEl = document.querySelector('.game-controls');
        const gameOverModal = document.getElementById("gameOverModal");
        const initialsModal = document.getElementById("initialsModal");
        const highscoreListModal = document.getElementById("highscoreListModal");
        const finalScoreDisplay = document.getElementById("finalScore");
        
        const boardSize = 10;
        const nextPieceSize = 5;
        const cellClass = 'grid-cell';

        let gameBoard = [];
        let score = 0;
        let isHardMode = false;
        let isGameRunning = false;
        
        let initialsEntryMode = false;
        const characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split('');
        let currentInitials = ['A', 'A', 'A'];
        let selectedInitialIndex = 0;

        const pieces = [
            [[1, 1, 1, 1]], // I-piece
            [[1, 1, 1], [0, 0, 1]], // J-piece
            [[1, 1, 1], [1, 0, 0]], // L-piece
            [[1, 1], [1, 1]], // O-piece
            [[0, 1, 1], [1, 1, 0]], // S-piece
            [[1, 1, 1], [0, 1, 0]], // T-piece
            [[1, 1, 0], [0, 1, 1]], // Z-piece
            [[1]] // 1x1 block
        ];
        
        let currentPiece = null;
        let currentPieceOriginal = null;
        let currentPieceSize = 0;
        let lastOneByOneCount = 0;
        let selectedPosition = null;

        const initGame = (hardMode) => {
            isHardMode = hardMode;
            isGameRunning = true;
            score = 0;
            gameBoard = Array(boardSize).fill(0).map(() => Array(boardSize).fill(0));
            scoreDisplay.textContent = `Po√§ng: 0`;
            renderGrid(gameGridEl, boardSize);
            renderGrid(nextPieceGridEl, nextPieceSize);
            newPiece();
            
            gameControlsEl.style.display = 'none';
            startGameBtn.style.display = 'none';
            rotateBtn.style.display = isHardMode ? 'none' : 'block';
            hideModals();
        };

        const hideModals = () => {
            gameOverModal.classList.remove('active');
            initialsModal.classList.remove('active');
            highscoreListModal.classList.remove('active');
        };

        const renderGrid = (gridEl, size) => {
            gridEl.innerHTML = '';
            for (let i = 0; i < size * size; i++) {
                const cell = document.createElement('div');
                cell.classList.add(cellClass);
                gridEl.appendChild(cell);
            }
        };

        const renderBoard = () => {
            const cells = gameGridEl.children;
            for (let y = 0; y < boardSize; y++) {
                for (let x = 0; x < boardSize; x++) {
                    const cellIndex = y * boardSize + x;
                    if (gameBoard[y][x] === 1) {
                        cells[cellIndex].classList.add('placed');
                    } else {
                        cells[cellIndex].classList.remove('placed');
                    }
                }
            }
        };
        
        const renderNextPiece = () => {
            const cells = Array.from(nextPieceGridEl.children);
            cells.forEach(cell => cell.classList.remove('next-piece-block'));

            if (!currentPiece) return;

            const pieceHeight = currentPiece.length;
            const pieceWidth = currentPiece[0].length;
            
            const startY = Math.floor((nextPieceSize - pieceHeight) / 2);
            const startX = Math.floor((nextPieceSize - pieceWidth) / 2);

            for (let y = 0; y < pieceHeight; y++) {
                for (let x = 0; x < pieceWidth; x++) {
                    if (currentPiece[y][x] === 1) {
                        const cellIndex = (y + startY) * nextPieceSize + (x + startX);
                        cells[cellIndex].classList.add('next-piece-block');
                    }
                }
            }
        };
        
        const newPiece = () => {
            let pieceIndex = Math.floor(Math.random() * (pieces.length));
            if (pieceIndex === pieces.length - 1 && lastOneByOneCount < 10) {
                 pieceIndex = Math.floor(Math.random() * (pieces.length - 1));
                 lastOneByOneCount++;
            } else if (pieceIndex === pieces.length - 1) {
                lastOneByOneCount = 0;
            } else {
                lastOneByOneCount++;
            }
            
            currentPieceOriginal = pieces[pieceIndex];
            currentPiece = isHardMode ? rotatePiece(currentPieceOriginal, Math.floor(Math.random() * 4)) : currentPieceOriginal;
            currentPieceSize = currentPieceOriginal.reduce((sum, row) => sum + row.filter(cell => cell === 1).length, 0);
            renderNextPiece();
            
            // Check for game over condition
            if (!canPlaceAnyRotation()) {
                gameOver();
            }
        };

        const canPlacePiece = (startX, startY, piece) => {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] === 1) {
                        const boardX = startX + x;
                        const boardY = startY + y;
                        if (boardX < 0 || boardX >= boardSize || boardY < 0 || boardY >= boardSize || gameBoard[boardY][boardX] === 1) {
                            return false;
                        }
                    }
                }
            }
            return true;
        };
        
        const canPlaceAnyRotation = () => {
            // Check current piece
            for (let y = 0; y < boardSize; y++) {
                for (let x = 0; x < boardSize; x++) {
                    if (canPlacePiece(x, y, currentPiece)) {
                        return true;
                    }
                }
            }

            // In Easy mode, also check all possible rotations
            if (!isHardMode) {
                for (let i = 1; i < 4; i++) {
                    const rotated = rotatePiece(currentPiece, i);
                    for (let y = 0; y < boardSize; y++) {
                        for (let x = 0; x < boardSize; x++) {
                            if (canPlacePiece(x, y, rotated)) {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        };
        

        const placePiece = (startX, startY, piece) => {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] === 1) {
                        gameBoard[startY + y][startX + x] = 1;
                    }
                }
            }
            score += currentPieceSize;
            checkLines();
            renderBoard();
            
            if (!canPlaceAnyRotation()) {
                gameOver();
            } else {
                newPiece();
            }
            selectedPosition = null; 
        };

        const checkLines = () => {
            const rowsToRemove = [];
            const colsToRemove = [];

            // Check rows
            for (let y = 0; y < boardSize; y++) {
                if (gameBoard[y].every(cell => cell === 1)) {
                    rowsToRemove.push(y);
                }
            }

            // Check columns
            for (let x = 0; x < boardSize; x++) {
                let fullColumn = true;
                for (let y = 0; y < boardSize; y++) {
                    if (gameBoard[y][x] === 0) {
                        fullColumn = false;
                        break;
                    }
                }
                if (fullColumn) {
                    colsToRemove.push(x);
                }
            }
            
            if (rowsToRemove.length > 0) {
                score += (rowsToRemove.length * 10);
            }
            
            if (colsToRemove.length > 0) {
                score += (colsToRemove.length * 10);
            }

            if (rowsToRemove.length > 0 || colsToRemove.length > 0) {
                let newBoard = Array(boardSize).fill(0).map(() => Array(boardSize).fill(0));
                let placedCells = [];
                for (let y = 0; y < boardSize; y++) {
                    for (let x = 0; x < boardSize; x++) {
                        if (gameBoard[y][x] === 1 && !rowsToRemove.includes(y) && !colsToRemove.includes(x)) {
                            placedCells.push({x,y});
                        }
                    }
                }
                placedCells.forEach(cell => {
                    newBoard[cell.y][cell.x] = 1;
                });
                gameBoard = newBoard;
            }

            scoreDisplay.textContent = `Po√§ng: ${score}`;
        };

        const rotatePiece = (piece, times = 1) => {
            let rotated = piece;
            for (let i = 0; i < times; i++) {
                rotated = rotated[0].map((_, index) => rotated.map(row => row[index]).reverse());
            }
            return rotated;
        };
        
        const gameOver = () => {
            isGameRunning = false;
            finalScoreDisplay.textContent = score;
            
            const isNewHighscore = topTenHighscores.length < 10 || score > (topTenHighscores.length > 0 ? topTenHighscores[topTenHighscores.length - 1].score : 0);

            if (isNewHighscore) {
                document.getElementById("newHighScoreMessage").style.display = "block";
                initialsEntryMode = true;
                
                setTimeout(() => {
                    hideModals();
                    initialsModal.classList.add('active');
                    selectedInitialIndex = 0; 
                    renderInitials();
                }, 2000); 
            } else {
                saveHighScore(score, "---"); // Save the score even if not a top 10
                hideModals();
                gameOverModal.classList.add('active');
            }
        };
        
        const renderInitials = () => {
            document.getElementById('initial-char-0').textContent = currentInitials[0];
            document.getElementById('initial-char-1').textContent = currentInitials[1];
            document.getElementById('initial-char-2').textContent = currentInitials[2];

            document.querySelectorAll('.initial-char').forEach((el, index) => {
                el.classList.toggle('selected', index === selectedInitialIndex);
            });
        };

        // --- Event listeners and game interaction ---
        
        gameGridEl.addEventListener('mousemove', (e) => {
            if (!isGameRunning || initialsEntryMode) return;
            
            const rect = gameGridEl.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / (rect.width / boardSize));
            const y = Math.floor((e.clientY - rect.top) / (rect.height / boardSize));
            
            // Ta bort gammal skugga
            const cells = Array.from(gameGridEl.children);
            cells.forEach(cell => cell.classList.remove('shadow', 'invalid-placement'));
            
            const pieceToPlace = !isHardMode && canPlacePiece(x, y, currentPiece) ? currentPiece : null;
            
            if (pieceToPlace) {
                for (let py = 0; py < pieceToPlace.length; py++) {
                    for (let px = 0; px < pieceToPlace[py].length; px++) {
                        if (pieceToPlace[py][px] === 1) {
                            const cellIndex = (y + py) * boardSize + (x + px);
                            if (cellIndex < cells.length) {
                                cells[cellIndex].classList.add('shadow');
                            }
                        }
                    }
                }
            } else {
                 for (let py = 0; py < currentPiece.length; py++) {
                    for (let px = 0; px < currentPiece[py].length; px++) {
                        if (currentPiece[py][px] === 1) {
                            const cellIndex = (y + py) * boardSize + (x + px);
                            if (cellIndex < cells.length) {
                                cells[cellIndex].classList.add('invalid-placement');
                            }
                        }
                    }
                }
            }
        });
        
        gameGridEl.addEventListener('click', (e) => {
            if (!isGameRunning || initialsEntryMode) return;

            const rect = gameGridEl.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / (rect.width / boardSize));
            const y = Math.floor((e.clientY - rect.top) / (rect.height / boardSize));
            
            if (canPlacePiece(x, y, currentPiece)) {
                placePiece(x, y, currentPiece);
            }
        });
        
        rotateBtn.addEventListener('click', () => {
            if (!isGameRunning || isHardMode) return;
            score--;
            scoreDisplay.textContent = `Po√§ng: ${score}`;
            currentPiece = rotatePiece(currentPiece);
            renderNextPiece();
        });
        
        document.addEventListener('keydown', (e) => {
            if (initialsModal.classList.contains('active')) {
                e.preventDefault(); 
                const charIndex = characterSet.indexOf(currentInitials[selectedInitialIndex]);

                if (e.key === "ArrowLeft") {
                    selectedInitialIndex = (selectedInitialIndex - 1 + 3) % 3;
                    renderInitials();
                } else if (e.key === "ArrowRight") {
                    selectedInitialIndex = (selectedInitialIndex + 1) % 3;
                    renderInitials();
                } else if (e.key === "ArrowUp") {
                    const newCharIndex = (charIndex + 1) % characterSet.length;
                    currentInitials[selectedInitialIndex] = characterSet[newCharIndex];
                    renderInitials();
                } else if (e.key === "ArrowDown") {
                    const newCharIndex = (charIndex - 1 + characterSet.length) % characterSet.length;
                    currentInitials[selectedInitialIndex] = characterSet[newCharIndex];
                    renderInitials();
                } else if (e.key === "Enter") {
                    document.getElementById("saveInitialsBtn").click();
                }
                return;
            }

            if (!isGameRunning) return;
            if (e.key === ' ' && !isHardMode) {
                e.preventDefault();
                score--;
                scoreDisplay.textContent = `Po√§ng: ${score}`;
                currentPiece = rotatePiece(currentPiece);
                renderNextPiece();
            }
        });
        
        startGameBtn.addEventListener('click', () => {
            initGame(isHardMode);
        });

        easyModeBtn.addEventListener('click', () => {
            isHardMode = false;
            easyModeBtn.classList.add('selected');
            hardModeBtn.classList.remove('selected');
        });
        hardModeBtn.addEventListener('click', () => {
            isHardMode = true;
            hardModeBtn.classList.add('selected');
            easyModeBtn.classList.remove('selected');
        });

        document.getElementById("saveInitialsBtn").addEventListener("click", () => {
            const initials = currentInitials.join('');
            saveHighScore(score, initials);
            initialsEntryMode = false;
            hideModals();
            gameOverModal.classList.add('active'); // Show Game Over modal after saving
        });
        
        // Initial setup
        renderGrid(gameGridEl, boardSize);
        renderGrid(nextPieceGridEl, nextPieceSize);
        setupFirebase();
    </script>
</body>
</html>
